//
// automatically generated by spin2cpp v1.03 on Sun Jun 02 19:48:38 2013
// spin2cpp SPI.spin 
//

#include <propeller.h>
#include "SPI.h"

#ifdef __GNUC__
#define INLINE__ static inline
#define PostEffect__(X, Y) __extension__({ int32_t tmp__ = (X); (X) = (Y); tmp__; })
#else
#define INLINE__ static
static int32_t tmp__;
#define PostEffect__(X, Y) (tmp__ = (X), (X) = (Y), tmp__)
#endif

INLINE__ int32_t Min__(int32_t a, int32_t b) { return a < b ? a : b; }
INLINE__ int32_t Max__(int32_t a, int32_t b) { return a > b ? a : b; }
INLINE__ int32_t Rotl__(uint32_t a, uint32_t b) { return (a<<b) | (a>>(32-b)); }
INLINE__ int32_t Rotr__(uint32_t a, uint32_t b) { return (a>>b) | (a<<(32-b)); }
INLINE__ int32_t Shr__(uint32_t a, uint32_t b) { return (a>>b); }
int32_t SPI::Start(int32_t _clockdelay, int32_t _clockstate)
{
  Clockstate = _clockstate;
  Clockdelay = (Max__((((CLKFREQ / 100000) * _clockdelay) - 4296), 381));
  return 0;
}

int32_t SPI::Shiftout(int32_t Dpin, int32_t Cpin, int32_t Mode, int32_t Bits, int32_t Value)
{
  DIRA = ((DIRA & (~(1 << Dpin))) | (1 << Dpin));
  OUTA = ((OUTA & (~(1 << Cpin))) | ((Clockstate & 0x1) << Cpin));
  DIRA = ((DIRA & (~(1 << Cpin))) | (1 << Cpin));
  if (Mode == 4) {
    Value = (Rotl__(Value, 1));
    {
      int32_t _idx__0000;
      int32_t _limit__0001 = Bits;
      for(_idx__0000 = 1; _idx__0000 <= _limit__0001; (_idx__0000 = (_idx__0000 + 1))) {
        OUTA = ((OUTA & (~(1 << Dpin))) | ((((Value = (Rotr__(Value, 1))) & 0x1) & 0x1) << Dpin));
        Postclock(Cpin);
      }
    }
  }
  if (Mode == 5) {
    Value = (Value << (32 - Bits));
    {
      int32_t _idx__0002;
      int32_t _limit__0003 = Bits;
      for(_idx__0002 = 1; _idx__0002 <= _limit__0003; (_idx__0002 = (_idx__0002 + 1))) {
        OUTA = ((OUTA & (~(1 << Dpin))) | ((((Value = (Rotl__(Value, 1))) & 0x1) & 0x1) << Dpin));
        Postclock(Cpin);
      }
    }
  }
  return 0;
}

int32_t SPI::Shiftin(int32_t Dpin, int32_t Cpin, int32_t Mode, int32_t Bits)
{
  int32_t	Value;
  DIRA &= ~(1<<Dpin);
  OUTA = ((OUTA & (~(1 << Cpin))) | ((Clockstate & 0x1) << Cpin));
  DIRA = ((DIRA & (~(1 << Cpin))) | (1 << Cpin));
  Value = 0;
  if (Mode == 0) {
    {
      int32_t _idx__0004;
      int32_t _limit__0005 = Bits;
      for(_idx__0004 = 1; _idx__0004 <= _limit__0005; (_idx__0004 = (_idx__0004 + 1))) {
        Value = ((Value << 1) | ((INA >> Dpin) & 0x1));
        Postclock(Cpin);
      }
    }
  }
  if (Mode == 1) {
    {
      int32_t _idx__0006;
      int32_t _limit__0007 = (Bits + 1);
      for(_idx__0006 = 1; _idx__0006 <= _limit__0007; (_idx__0006 = (_idx__0006 + 1))) {
        Value = ((Shr__(Value, 1)) | (((INA >> Dpin) & 0x1) << 31));
        Postclock(Cpin);
      }
    }
    Value = (Shr__(Value, (32 - Bits)));
  }
  if (Mode == 2) {
    {
      int32_t _idx__0008;
      int32_t _limit__0009 = Bits;
      for(_idx__0008 = 1; _idx__0008 <= _limit__0009; (_idx__0008 = (_idx__0008 + 1))) {
        Preclock(Cpin);
        Value = ((Value << 1) | ((INA >> Dpin) & 0x1));
      }
    }
  }
  if (Mode == 3) {
    {
      int32_t _idx__0010;
      int32_t _limit__0011 = (Bits + 1);
      for(_idx__0010 = 1; _idx__0010 <= _limit__0011; (_idx__0010 = (_idx__0010 + 1))) {
        Preclock(Cpin);
        Value = ((Shr__(Value, 1)) | (((INA >> Dpin) & 0x1) << 31));
      }
    }
    Value = (Shr__(Value, (32 - Bits)));
  }
  return Value;
}

int32_t SPI::Postclock(int32_t _cpin)
{
  waitcnt((CNT + Clockdelay));
  OUTA ^= (1<<_cpin);
  waitcnt((CNT + Clockdelay));
  OUTA ^= (1<<_cpin);
  return 0;
}

int32_t SPI::Preclock(int32_t _cpin)
{
  OUTA ^= (1<<_cpin);
  waitcnt((CNT + Clockdelay));
  OUTA ^= (1<<_cpin);
  waitcnt((CNT + Clockdelay));
  return 0;
}